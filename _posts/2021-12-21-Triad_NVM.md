---
layout: post
title: Triad-NVM:Persistency for Integrity-Protected and Encrypted Non-Volatile Memories
date: 2021-12-21
category: translation
---

# 摘要

非易失性存储器（NVM）被提出，它为主存储器提供了一种有吸引力的结构。与DRAM不同，NVMM在断电后保留数据。这允许内存在崩溃和重新启动期间持久承载数据，但为攻击者在启动期间窥探、篡改数据提供了机会。虽然DRAM系统的内存加密和完整性验证已经得到了很好的研究，但如果我们想同时保持安全保证、崩溃/重新启动的数据恢复、良好的持久性性能和快速恢复，NVM将面临新的挑战。

在本文中，我们使用所有安全元数据（计数器、MAC和Merkle树）探讨数据的持久性，以实现安全持久性。我们表明，为了确保安全保证，除了计数器之外，还需要维护消息身份验证码（MAC）和Bonsai Merkle树（BMT），它们导致了大部分的持久性开销。我们分析了实现持久性和非持久性内存区域的安全持久性的需求。我们发现，内存的非易失性可能会在重新启动时触发完整性验证失败，因此我们提出了一种单独的机制来支持非持久性内存区域。第四，我们提出了快速恢复的设计。我们的评估表明，与严格持久性相比，所提出的设计Triad-NVM可以将吞吐量平均提高2倍。此外，与没有安全元数据持久性的系统相比，Triad NVM可以实现数量级更快的恢复时间。

# 1. 引言

非易失性主存储器（NVMM）与DRAM相比，它提供了一系列引人注目的功能。最近发布的Intel Optane DC持久性内存提供高达3TB/插槽的高容量、低比特成本、字节寻址能力和非易失性。由于数据在没有电源的情况下仍保留在NVMM中，因此数据剩磁是一个真正的安全漏洞，因此Optane DC附带了硬件内存端加密。虽然内存端加密可以作为独立解决方案提供良好的第一道防线，但由于没有为应用程序提供安全的执行环境，它的安全保护较弱。为了实现更全面的保护，处理器端内存安全是必要的。

NVMM还支持持久化应用程序，这些应用程序可以在崩溃或重新启动后通过将数据持久化到内存中进行恢复。虽然持久性和安全性似乎是正交的，但它们应该在NVMM中一起研究，因为系统应该能够安全地恢复，并在崩溃/重新启动期间保证其数据完整性和机密性。然而，持久性和安全性在很大程度上是分开调查的；除了在冷启动攻击下，DRAM等易失性内存不具备跨崩溃恢复内存的功能。在这样的系统中，安全元数据预计将在启动时重新初始化。此外，最近关于持久性和安全性的研究侧重于正常运行的性能，而没有考虑跨崩溃和重新启动的持久性。最后，NVMM中的内存持久性和崩溃恢复是一个活跃的研究课题，但它们关注的是持久性问题，而不是安全性。

我们认为，由于数据剩磁漏洞，持久性和内存安全性需要综合考虑以下要求：
- **维护安全保障**。内存加密和完整性验证应保证数据的机密性和完整性，即使内存是非易失的。
- **数据可恢复性**。NVMM可分为持久性区域和非持久性区域，其中程序员在持久性区域中保存持久数据，在非持久性区域中保存临时数据。持久区域中的数据应可在崩溃和系统重新启动时恢复。同时，NVMM应该阻止从非持久性区域恢复数据。
- **快速持久性和恢复**。持久性不应显著降低执行速度。崩溃/重启后恢复应该相对较快，以确保高可用性。

目前的研究不符合上述所有要求。例如，最近的研究探索了NVMM上原子持久化的数据和加密计数器。虽然它们提供了数据可恢复性，但却忽略了数据和计数器的完整性保护，这对于计数器模式内存加密安全至关重要。因此，由于系统容易受到数据直接篡改和计数器重放攻击，即重放旧版本的数据及其计数器以逃避加密，因此无法保留安全保证。此外，研究也没有讨论如何区别对待内存的持久性和非持久性区域，也没有讨论恢复时间的问题。

本文介绍了在具有内存加密和完整性验证的系统环境中全面提供持久性的第一项工作。我们讨论了在采用内存加密和完整性验证的NVMM系统中持久化安全元数据的问题。稍后，我们定义了一个新概念，即**安全持久性**，它定义了安全恢复完整性保护和加密内存系统的要求。最后，我们讨论了几种松弛方案以及利用它们优化性能的综合设计。

本文的主要贡献如下。首先，我们展示了NVMM中的持久和非持久区域必须根据安全元数据进行不同的处理。其次，为了确保安全保障，除了计数器之外，还需要维护消息身份验证码（MAC）和Bonsai Merkle树（BMT）等元数据。第三，每次在NVMM中保存新的数据值时，BMT都需要从叶到根进行更新，否则数据可以恢复，但恢复后其完整性无法再得到保证。事实上，持久化BMT元数据比持久化计数器的开销高得多，因此之前的研究低估了在安全内存中持久化数据的开销。第四，对于非持久性数据，我们发现内存的非易失性可能会导致重新启动时的完整性验证失败，因此我们提出了一种单独的机制来支持非持久性内存区域。第五，我们展示了使用TB级的NVMM进行恢复可能需要一个多小时，因此我们提出了延迟恢复优化，以加快恢复速度。

为了评估我们的设计，我们使用Gem5，一个全系统周期精确模拟器。我们使用 Linux 内核版本 4.14 以及基于 Ubuntu 16.04 的磁盘映像。 此外，我们初始化内核以将最后 4GB（16GB 中的）专用于持久区域，稍后我们将其挂载为可直接访问 (DAX) ext4 文件系统。 任何支持持久内存的库都可以使用持久区域，但是，除了四个基于 DAX 的合成工作负载外，我们选择使用英特尔的 PMDK 库 [24]（以前称为 PMEM）来构建三个微基准测试，以及 12 个 来自 SPEC2006 套件的基准测试 [25]。 我们还评估了四种运行持久（PMDK 和 DAX）和非持久 (SPEC) 工作负载组合的工作负载。 我们的模拟结果表明 Triad-NVM 可以将吞吐量平均提高 2 倍（相对于严格的持久性）。 此外，Triad-NVM 对于 8TB NVM 系统保持不到 4 秒的恢复时间（64TB 为 30.6 秒），这比没有安全元数据持久性的系统快 3648 倍。

本文的其余部分安排如下。 首先，我们在第 2 节中讨论了安全 NVM 系统的问题和背景，我们还讨论了在安全 NVM 中持久保存安全元数据的传统方法。 稍后，在第 3 节中，我们将讨论安全持久内存系统的要求。 稍后，我们将讨论不同的松弛方案及其对 NVM 系统的安全性、性能和弹性的影响。 在第 4 节中，我们讨论了我们的评估方法。 我们的评估结果和讨论在第 5 节中介绍。第 6 节讨论了与我们的论文最相关的工作。 最后，我们在第 7 节结束我们的工作。我们将从背景讨论开始我们的部分，然后讨论安全元数据的崩溃一致性问题。 稍后，我们将提供有关问题影响的动机数据。

# 2. 背景和动机

我们将从背景讨论开始我们的部分，然后讨论安全元数据的崩溃一致性问题。 稍后，我们将提供有关问题影响的动机数据。

## 2.1 背景

非易失性主存储器 (NVMM)，例如 Micron 3D XPoint 或 Intel DC Persistent Memory [26]，即将面世，预计很快就会上市。 与 DRAM 相比，它们具有更高的密度、更低的每比特成本和更低的空闲功耗，并且具有非易失性 [27-29]，但访问延迟更高且写入耐久性有限。 由于它们的非易失性，它们可以用作托管文件系统的存储，或用作持久或非持久内存。 具体来说，基于 NVM 的 DIMM 可用于保存文件和常规内存页面，并且可以通过加载/存储操作以类似于 DRAM 的方式进行访问。 为了实现这一点，新的操作系统 (OS) 开始支持将内存配置为持久性和传统的非持久性内存。 例如，最近的 Linux 内核和 Windows 开始支持对文件系统的直接访问 (DAX) [30]。 在支持 DAX 的文件系统中，例如带有 DAX 的 ext4，文件可以直接进行内存映射并通过典型的加载/存储操作访问，而无需像在传统文件系统中那样将其页面复制到页面缓存。 例如，NVMM 可以配置为具有专用于保存文件系统的分区。 在 Linux 中，在初始化内核时，可以使用参数 memmap=4G!12G 将地址 12GB 开始的 4GB 专用于可直接访问的文件系统。 因此，单个物理内存空间可以托管持久区域（用于文件）和非持久区域（用于常规内存页面）。

### 2.1.1 NVM安全

由于非易失性，NVM 容易受到被动机密性破坏（例如通过数据剩余攻击）以及通过数据篡改导致的主动完整性破坏。非易失性为攻击者提供了充足的时间在操作期间执行被动和主动攻击，但最重要的是在通电事件之间的关闭周期期间。 因此，NVM 必须与内存加密和完整性验证相结合。加密可以在内存端或处理器端执行。内存端加密是针对依赖内存作为信任根的内存产品的独立解决方案。它嵌入了一个加密引擎，在将数据写入内存行之前对其进行加密，并在将其发送到处理器之前对其进行解密。但是，它的保护较弱。数据仍以明文形式在系统总线上进行通信，从而使其面临机密性泄露。与处理器建立安全通信通道需要复杂的身份验证过程。它也不能为处理器上运行的应用程序提供安全的执行环境，因为它无法区分来自处理器的访问请求的合法性。处理器端内存加密以处理器芯片为安全边界，从而消除了上述缺点，但需要对处理器进行修改。数据在离开处理器芯片之前被加密，当它从 NVMM 获取时，它被解密并验证其完整性。

### 2.1.2 内存加密和完整性验证

在计数器模式加密中，加密算法（例如 AES）以初始化向量 (IV) 作为其输入以生成一次性填充 (OTP)，如图 2 所示。稍后，当块到达处理器芯片时， 执行与填充（加密的 IV）的低成本按位异或以获得明文。 通过这样做，解密延迟与内存访问延迟重叠。 除了其性能优势之外，反模式内存加密还可以防御各种攻击。 反模式加密可以安全地抵御基于字典的攻击、已知明文攻击和总线窥探攻击。

![](/images/Triad-NVM/split_counter_mode_encryption.png)

有几种可能的计数器格式，包括单片（在 SGX 中使用）和拆分格式。Monolithic 对所有内存块使用一个（全局）计数器，每次将任何块写回内存 10 时，计数器都会增加，以避免计数器重用。 全局计数器的溢出需要代价高昂的整个内存重新加密。 因此，单片计数器需要很大，例如 64 位。 由于用于加密块的计数器值需要保留和检索以备将来解密，因此大型计数器还需要大型片上缓存以降低计数器缓存未命中率。 在拆分计数器方案中，加密计数器被组织为主要计数器（在同一页面的缓存块之间共享）和特定于每个缓存块的次要计数器 [7]。 这种组织允许将 64 个缓存块的计数器打包到一个 64B 块中；  7 位次要计数器和 64 位主要计数器。 当主计数器的一个或计数器溢出时，主计数器会增加，其中所有相应的次计数器将被重置，整个页面将使用新的主计数器 [7] 重新加密。 主计数器足够大（例如 64 位），不会在系统生命周期内溢出。 拆分计数器方案比单片计数器方案的空间效率高得多，并且实现了更高的计数器命中率，因此它的性能明显优于单片计数器方案。 因此，我们假设了一个拆分计数器方案，正如最近的研究[7-9, 31] 中所假设的那样。

![](/images/Triad-NVM/merkle_tree.png)

反模式加密的基本安全保证要求计数器值不能重复，否则加密可以被破解。 为避免计数器重放，计数器必须通过默克尔树（称为盆景默克尔树或 BMT [22]）防止篡改。 这是先前研究中忽略的一个方面。 使用 BMT，数据只需要通过 MAC 而不是 Merkle Tree 保护。 如图 1 所示，每个与一组数据块相关联的加密计数器块用于计算哈希值 (MAC)，该哈希值将与来自其他计数器组的其他哈希值一起使用以创建较低级别 哈希值。 最后，生成的 MAC 值称为根，始终保存在处理器中。 每次从不安全区域（例如内存模块）中取出计数器时，都会通过计算上哈希值来验证它，并查看结果是否与处理器中保存的根匹配。 此外，当处理器写入内存块并更新相应的计数器时，必须更新 BMT 父节点以反映最近的更改。修改传播到根取决于数据恢复的要求。

### 2.1.3 持久性对安全性的影响

NVMM 可能托管持久数据，这些数据需要在崩溃/重启后恢复。 由于加密数据需要使用用于对其进行加密的正确（最新）计数器值进行解密，因此当数据保留在内存中时，其计数器也必须保留。 否则，在崩溃时，如果使用过时的计数器值解密，则数据可能无法恢复。 刘等 [18] 进行了这一观察并提出了以原子方式持久化数据及其计数器的方案，要么严格（在每个持久化），要么在纪元或事务边界。 原子性不仅需要保证可恢复性，还需要保证加密的安全性，因为内存中的陈旧计数器可用于诱导填充重用 [19]。

## 2.2 安全元数据崩溃一致性

重要的是不仅要持久化数据及其计数器。 如前所述，计数器模式加密从根本上依赖于要保持的计数器的完整性。 因此，崩溃恢复也必须考虑默克尔树。 发生崩溃后，系统必须能够恢复和恢复其加密的内存数据及其随附的安全元数据。 图 3 讨论了 Ye 等人 [19] 所描述的崩溃一致性所需的逻辑步骤。

![](/images/Triad-NVM/write_process_ensure_crash_consistency.png)

如图 3 所示，BMT（片上）的根应该与处理器内受影响的中间节点一起更新/保持（步骤 1），一直到 BMT 的根。 然而，只有树的根需要保留在安全区域中。 在步骤 2 中，更新的计数器块在计数器缓存中更新时被持久化（写入内存）。 最后，在步骤 3 中，写入的数据块将被发送到内存中。 请注意，更新根、计数器和数据可以通过内部 NVM 寄存器或易失性寄存器自动完成，一旦检测到崩溃，这些寄存器或易失性寄存器将被复制到内部 NVM 寄存器中[19]。

